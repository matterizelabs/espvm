#!/bin/bash
# espvm - ESP SDK Version Manager
# Manage multiple ESP-IDF and ESP-Matter versions using git worktree

# Configuration paths
ESPVM_CONFIG_DIR="${ESPVM_CONFIG_DIR:-$HOME/.espressif/.espvm}"
ESPVM_CONFIG_FILE="$ESPVM_CONFIG_DIR/config"

# Global flags
_ESPVM_VERBOSE=0

# SDK configurations
declare -A _ESPVM_SDKS=(
    [idf]="esp-idf"
    [matter]="esp-matter"
)

declare -A _ESPVM_SDK_REPOS=(
    [idf]="espressif/esp-idf"
    [matter]="espressif/esp-matter"
)

# Colors for output
_espvm_red() { echo -e "\033[0;31m$1\033[0m"; }
_espvm_green() { echo -e "\033[0;32m$1\033[0m"; }
_espvm_yellow() { echo -e "\033[0;33m$1\033[0m"; }
_espvm_blue() { echo -e "\033[0;34m$1\033[0m"; }

# Run command quietly, show output on error or if verbose
_espvm_run_quiet() {
    local tmpfile=$(mktemp)
    if [[ $_ESPVM_VERBOSE -eq 1 ]]; then
        "$@"
        local ret=$?
        rm -f "$tmpfile"
        return $ret
    else
        "$@" > "$tmpfile" 2>&1
        local ret=$?
        if [[ $ret -ne 0 ]]; then
            cat "$tmpfile"
        fi
        rm -f "$tmpfile"
        return $ret
    fi
}

# Source script quietly, capture output for error detection
_espvm_source_quiet() {
    local script="$1"
    local tmpfile=$(mktemp)
    if [[ $_ESPVM_VERBOSE -eq 1 ]]; then
        source "$script"
        local ret=$?
        rm -f "$tmpfile"
        return $ret
    else
        source "$script" > "$tmpfile" 2>&1
        local ret=$?
        # Check for failure indicators
        if grep -qE "(FAILED|ERROR:)" "$tmpfile"; then
            cat "$tmpfile"
            rm -f "$tmpfile"
            return 1
        fi
        rm -f "$tmpfile"
        return $ret
    fi
}

# Check if a command exists
_espvm_command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Ensure prerequisites are met
_espvm_check_prereqs() {
    if ! _espvm_command_exists git; then
        _espvm_red "Error: git is not installed"
        return 1
    fi
    if ! _espvm_command_exists python3; then
        _espvm_red "Error: python3 is not installed"
        return 1
    fi
    return 0
}

# Load configuration
_espvm_load_config() {
    # Reset to defaults
    ESPVM_WORKTREE_DIR=""
    ESPVM_USE_SSH="auto"

    if [[ -f "$ESPVM_CONFIG_FILE" ]]; then
        source "$ESPVM_CONFIG_FILE"
    fi
}

# Save configuration
_espvm_save_config() {
    mkdir -p "$ESPVM_CONFIG_DIR"
    cat > "$ESPVM_CONFIG_FILE" << EOF
ESPVM_WORKTREE_DIR="$ESPVM_WORKTREE_DIR"
ESPVM_USE_SSH="$ESPVM_USE_SSH"
EOF
}

# Get worktree directory, prompting user if not configured
_espvm_get_worktree_dir() {
    # Check command line override first
    if [[ -n "$_ESPVM_WORKTREE_FLAG" ]]; then
        echo "$_ESPVM_WORKTREE_FLAG"
        return
    fi

    _espvm_load_config

    # Return if already configured
    if [[ -n "$ESPVM_WORKTREE_DIR" ]]; then
        echo "$ESPVM_WORKTREE_DIR"
        return
    fi

    # First time - ask user (print to stderr so it's not captured)
    echo "" >&2
    _espvm_blue "First-time setup: Where would you like to store ESP SDK versions?" >&2
    echo "  [1] ~/.espressif/versions (default)" >&2
    echo "  [2] Custom path" >&2
    echo "" >&2
    read -p "Choice [1]: " choice

    case "$choice" in
        2)
            read -p "Enter path: " custom_path
            # Expand ~ and convert to absolute path
            custom_path="${custom_path/#\~/$HOME}"
            if [[ "$custom_path" != /* ]]; then
                custom_path="$(cd "$custom_path" 2>/dev/null && pwd)" || custom_path="$(pwd)/$custom_path"
            fi
            ESPVM_WORKTREE_DIR="$custom_path"
            ;;
        *)
            ESPVM_WORKTREE_DIR="$HOME/.espressif/versions"
            ;;
    esac

    # Save to config
    _espvm_save_config
    _espvm_green "Configuration saved to $ESPVM_CONFIG_FILE" >&2
    echo "" >&2

    echo "$ESPVM_WORKTREE_DIR"
}

# Check if SSH is configured for GitHub
_espvm_check_ssh() {
    # Quick test - check if ssh key auth works for github
    ssh -o BatchMode=yes -o ConnectTimeout=5 -T git@github.com 2>&1 | grep -q "successfully authenticated"
    return $?
}

# Get repository URL for an SDK
_espvm_get_repo_url() {
    local sdk="$1"  # idf or matter
    local sdk_repo="${_ESPVM_SDK_REPOS[$sdk]}"

    _espvm_load_config
    local use_ssh="${ESPVM_USE_SSH:-auto}"

    if [[ "$use_ssh" == "auto" ]]; then
        if _espvm_check_ssh; then
            use_ssh="yes"
        else
            use_ssh="no"
        fi
    fi

    if [[ "$use_ssh" == "yes" ]]; then
        echo "git@github.com:${sdk_repo}.git"
    else
        echo "https://github.com/${sdk_repo}.git"
    fi
}

# Get the bare repo directory for an SDK
_espvm_get_bare_dir() {
    local sdk="$1"
    local sdk_name="${_ESPVM_SDKS[$sdk]}"
    echo "$ESPVM_CONFIG_DIR/${sdk_name}.bare"
}

# Get the SDK versions directory
_espvm_get_sdk_dir() {
    local sdk="$1"
    local worktree_dir="$(_espvm_get_worktree_dir)"
    # Remove trailing slash and convert to absolute path
    worktree_dir="${worktree_dir%/}"
    if [[ "$worktree_dir" != /* ]]; then
        worktree_dir="$(cd "$worktree_dir" 2>/dev/null && pwd)" || worktree_dir="$(pwd)/$worktree_dir"
    fi
    local sdk_name="${_ESPVM_SDKS[$sdk]}"
    echo "$worktree_dir/$sdk_name"
}

# Get the current file path for an SDK
_espvm_get_current_file() {
    local sdk="$1"
    local sdk_dir="$(_espvm_get_sdk_dir "$sdk")"
    echo "$sdk_dir/.current"
}

# Normalize version string (add 'v' prefix if missing for tags)
_espvm_normalize_version() {
    local version="$1"
    # Don't add v prefix for branch names (they typically contain / or are like master, main, release/*)
    if [[ "$version" =~ ^[0-9] ]]; then
        echo "v$version"
    else
        echo "$version"
    fi
}

# Encode version for filesystem (replace / with -)
_espvm_encode_version() {
    echo "${1//\//-}"
}

# Decode version from filesystem (replace - with / for known patterns)
_espvm_decode_version() {
    local ver="$1"
    # Only decode release-* pattern back to release/*
    if [[ "$ver" == release-* ]]; then
        echo "${ver/release-/release\/}"
    else
        echo "$ver"
    fi
}

# Initialize the bare repository if it doesn't exist
_espvm_init_bare() {
    local sdk="$1"
    local bare_dir="$(_espvm_get_bare_dir "$sdk")"
    local repo_url="$(_espvm_get_repo_url "$sdk")"
    local sdk_name="${_ESPVM_SDKS[$sdk]}"

    if [[ ! -d "$bare_dir" ]]; then
        echo "Initializing $sdk_name repository..."
        mkdir -p "$(dirname "$bare_dir")"
        git clone --bare "$repo_url" "$bare_dir"
        if [[ $? -ne 0 ]]; then
            _espvm_red "Error: Failed to clone $sdk_name repository"
            return 1
        fi
        # Configure the bare repo for worktrees
        git -C "$bare_dir" config remote.origin.fetch "+refs/heads/*:refs/remotes/origin/*"
        _espvm_green "Repository initialized successfully"
    fi
    return 0
}

# Ensure bare repo exists, recover if needed for existing worktrees
_espvm_ensure_bare() {
    local sdk="$1"
    local bare_dir="$(_espvm_get_bare_dir "$sdk")"

    if [[ ! -d "$bare_dir" ]]; then
        _espvm_yellow "Bare repository missing, reinitializing..."
        _espvm_init_bare "$sdk" || return 1
        _espvm_repair_worktrees "$sdk"
    fi
    return 0
}

# Repair broken worktree links
_espvm_repair_worktrees() {
    local sdk="$1"
    local bare_dir="$(_espvm_get_bare_dir "$sdk")"
    local sdk_dir="$(_espvm_get_sdk_dir "$sdk")"

    [[ ! -d "$bare_dir" ]] && return 0
    [[ ! -d "$sdk_dir" ]] && return 0

    # Fix each worktree's .git file to point to current bare repo
    for dir in "$sdk_dir"/*/; do
        [[ ! -d "$dir" ]] && continue
        local wt_name=$(basename "$dir")
        local git_file="${dir}.git"
        local wt_git_dir="$bare_dir/worktrees/$wt_name"

        # Create worktrees entry if missing
        if [[ ! -d "$wt_git_dir" ]]; then
            mkdir -p "$wt_git_dir"
            echo "$dir" > "$wt_git_dir/gitdir"
            # Get current HEAD
            local head_ref=$(git -C "$dir" rev-parse HEAD 2>/dev/null)
            [[ -n "$head_ref" ]] && echo "$head_ref" > "$wt_git_dir/HEAD"
        fi

        # Fix the .git file in worktree to point to bare repo
        if [[ -f "$git_file" ]]; then
            echo "gitdir: $wt_git_dir" > "$git_file"
        fi
    done

    # Run git's repair as well
    git -C "$bare_dir" worktree repair "$sdk_dir" 2>/dev/null
    return 0
}

# Check if tools are installed for a version (ESP-IDF specific)
_espvm_check_tools() {
    local version_dir="$1"
    if [[ ! -f "$version_dir/tools/idf_tools.py" ]]; then
        return 1
    fi
    IDF_PATH="$version_dir" python3 "$version_dir/tools/idf_tools.py" check >/dev/null 2>&1
    return $?
}

# Run install.sh if needed (force=1 to skip check)
_espvm_maybe_install() {
    local version_dir="$1"
    local version="$2"
    local sdk="$3"
    local force="${4:-0}"

    # Check if install.sh exists
    if [[ ! -f "$version_dir/install.sh" ]]; then
        _espvm_yellow "No install.sh found, skipping tools installation"
        return 0
    fi

    # For ESP-IDF, check if tools are already installed (unless force)
    if [[ "$sdk" == "idf" && "$force" -ne 1 ]]; then
        if _espvm_check_tools "$version_dir"; then
            _espvm_green "Tools already installed for $version"
            return 0
        fi
    fi

    echo -n "Installing tools for $version... "
    if (cd "$version_dir" && _espvm_run_quiet ./install.sh); then
        _espvm_green "done"
        return 0
    else
        _espvm_red "failed"
        return 1
    fi
}

# Install a specific version
_espvm_install() {
    local sdk="$1"
    local version="$2"
    shift 2

    # Parse additional flags
    _ESPVM_WORKTREE_FLAG=""
    local force=0
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --path=*)
                _ESPVM_WORKTREE_FLAG="${1#*=}"
                _ESPVM_WORKTREE_FLAG="${_ESPVM_WORKTREE_FLAG/#\~/$HOME}"
                shift
                ;;
            --path)
                _ESPVM_WORKTREE_FLAG="$2"
                _ESPVM_WORKTREE_FLAG="${_ESPVM_WORKTREE_FLAG/#\~/$HOME}"
                shift 2
                ;;
            --force|-f)
                force=1
                shift
                ;;
            --verbose|-v)
                _ESPVM_VERBOSE=1
                shift
                ;;
            *)
                _espvm_red "Unknown option: $1"
                return 1
                ;;
        esac
    done

    if [[ -z "$version" ]]; then
        _espvm_red "Usage: espvm $sdk install <version> [--path=<dir>] [--force]"
        return 1
    fi

    _espvm_check_prereqs || return 1

    local sdk_name="${_ESPVM_SDKS[$sdk]}"
    version=$(_espvm_normalize_version "$version")
    local encoded_version=$(_espvm_encode_version "$version")
    local sdk_dir="$(_espvm_get_sdk_dir "$sdk")"
    local version_dir="$sdk_dir/$encoded_version"
    local bare_dir="$(_espvm_get_bare_dir "$sdk")"

    if [[ -d "$version_dir" ]]; then
        if [[ $force -eq 1 ]]; then
            _espvm_yellow "Reinstalling tools for $sdk_name $version..."
            _espvm_maybe_install "$version_dir" "$version" "$sdk" 1 || return 1
            _espvm_green "Tools reinstalled successfully"
            return 0
        fi
        _espvm_yellow "$sdk_name $version is already installed at $version_dir"
        echo "Use --force to reinstall tools"
        return 0
    fi

    echo "Installing $sdk_name $version..."

    # Initialize bare repo if needed
    _espvm_init_bare "$sdk" || return 1

    # Fetch the specific tag/branch
    echo "Fetching $version..."
    # Try as tag first, then as branch
    if ! git -C "$bare_dir" fetch origin tag "$version" --no-tags 2>/dev/null; then
        echo "Not a tag, trying as branch..."
        git -C "$bare_dir" fetch origin "$version"
        if [[ $? -ne 0 ]]; then
            _espvm_red "Error: Failed to fetch $version (does this version exist?)"
            return 1
        fi
    fi

    # Create worktree (prune stale ones first)
    echo "Creating worktree for $version..."
    mkdir -p "$sdk_dir"
    git -C "$bare_dir" worktree prune 2>/dev/null
    if ! git -C "$bare_dir" worktree add "$version_dir" "$version" 2>/dev/null; then
        # Worktree might exist in git but directory is gone/stale
        _espvm_yellow "Cleaning up stale worktree reference..."
        git -C "$bare_dir" worktree remove "$version_dir" --force 2>/dev/null
        git -C "$bare_dir" worktree prune 2>/dev/null
        git -C "$bare_dir" worktree add "$version_dir" "$version"
        if [[ $? -ne 0 ]]; then
            _espvm_red "Error: Failed to create worktree"
            return 1
        fi
    fi

    # Initialize submodules - different approach for matter vs idf
    if [[ "$sdk" == "matter" ]]; then
        # ESP-Matter requires ESP-IDF to be active
        if [[ -z "$IDF_PATH" ]]; then
            _espvm_red "Error: ESP-IDF must be active before installing ESP-Matter"
            echo "Run 'espvm idf use <version>' first"
            # Clean up the worktree we just created
            git -C "$bare_dir" worktree remove "$version_dir" --force 2>/dev/null
            return 1
        fi

        echo "Initializing submodules (shallow)..."
        git -C "$version_dir" submodule update --init --depth 1
        if [[ $? -ne 0 ]]; then
            _espvm_red "Error: Failed to initialize submodules"
            return 1
        fi

        # Use checkout_submodules.py for connectedhomeip (platform-specific)
        local chip_dir="$version_dir/connectedhomeip/connectedhomeip"
        if [[ -f "$chip_dir/scripts/checkout_submodules.py" ]]; then
            echo "Checking out CHIP submodules for esp32 linux..."
            if ! (cd "$chip_dir" && python3 scripts/checkout_submodules.py --platform esp32 linux --shallow); then
                _espvm_red "Error: Failed to checkout CHIP submodules"
                return 1
            fi
        fi
    else
        # ESP-IDF: regular recursive submodule update
        echo "Initializing submodules..."
        git -C "$version_dir" submodule update --init --recursive --jobs 8 --depth 1
        if [[ $? -ne 0 ]]; then
            _espvm_red "Error: Failed to initialize submodules"
            return 1
        fi
    fi

    # Install tools if needed
    _espvm_maybe_install "$version_dir" "$version" "$sdk" || return 1

    _espvm_green "$sdk_name $version installed successfully"
    echo "Run 'espvm $sdk use $version' to activate it"

    # Clear the flag
    _ESPVM_WORKTREE_FLAG=""
    return 0
}

# Switch to a specific version
_espvm_use() {
    local sdk="$1"
    local version="$2"
    shift 2 2>/dev/null || true

    # Parse flags
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --verbose|-v)
                _ESPVM_VERBOSE=1
                shift
                ;;
            *)
                shift
                ;;
        esac
    done

    if [[ -z "$version" ]]; then
        _espvm_red "Usage: espvm $sdk use <version> [-v]"
        return 1
    fi

    local sdk_name="${_ESPVM_SDKS[$sdk]}"
    version=$(_espvm_normalize_version "$version")
    local encoded_version=$(_espvm_encode_version "$version")
    local sdk_dir="$(_espvm_get_sdk_dir "$sdk")"
    local version_dir="$sdk_dir/$encoded_version"
    local current_file="$(_espvm_get_current_file "$sdk")"

    local just_installed=0
    if [[ ! -d "$version_dir" ]]; then
        _espvm_yellow "$sdk_name $version is not installed"
        read -p "Install it now? [y/N]: " answer
        if [[ "$answer" =~ ^[Yy]$ ]]; then
            _espvm_install "$sdk" "$version" || return 1
            just_installed=1
        else
            return 1
        fi
    fi

    # ESP-Matter requires ESP-IDF to be active
    if [[ "$sdk" == "matter" && -z "$IDF_PATH" ]]; then
        _espvm_red "Error: ESP-IDF must be active before using ESP-Matter"
        echo "Run 'espvm idf use <version>' first"
        return 1
    fi

    if [[ ! -f "$version_dir/export.sh" ]]; then
        _espvm_red "Error: export.sh not found in $version_dir"
        return 1
    fi

    # Repair worktree links if bare repo exists
    local bare_dir="$(_espvm_get_bare_dir "$sdk")"
    if [[ -d "$bare_dir" ]]; then
        git -C "$bare_dir" worktree repair "$version_dir" 2>/dev/null
    fi

    # Clear previous environment to avoid conflicts
    if [[ "$sdk" == "idf" ]]; then
        # Switching IDF versions - clear IDF environment
        if [[ -n "$IDF_PATH" ]]; then
            local old_idf="$IDF_PATH"
            PATH=$(echo "$PATH" | tr ':' '\n' | grep -vF "$old_idf" | tr '\n' ':')
            PATH="${PATH%:}"
            [[ -n "$IDF_TOOLS_PATH" ]] && PATH=$(echo "$PATH" | tr ':' '\n' | grep -vF "$IDF_TOOLS_PATH" | tr '\n' ':')
            PATH="${PATH%:}"
        fi
        unset IDF_PATH IDF_PYTHON_ENV_PATH IDF_TOOLS_PATH IDF_COMPONENT_MANAGER_URL
        unset OPENOCD_SCRIPTS ESP_IDF_VERSION ESP_ROM_ELF_DIR
        # Also clear matter env since it depends on IDF
        unset ESP_MATTER_PATH
    else
        # Switching Matter versions - preserve IDF, clear Matter
        if [[ -n "$ESP_MATTER_PATH" ]]; then
            PATH=$(echo "$PATH" | tr ':' '\n' | grep -vF "$ESP_MATTER_PATH" | tr '\n' ':')
            PATH="${PATH%:}"
        fi
        unset ESP_MATTER_PATH
    fi

    # Activate the version
    echo -n "Activating $sdk_name $version... "
    if ! _espvm_source_quiet "$version_dir/export.sh"; then
        _espvm_red "failed"
        if [[ $just_installed -eq 1 ]]; then
            return 1
        fi
        read -p "Run install.sh to fix? [y/N]: " answer
        if [[ "$answer" =~ ^[Yy]$ ]]; then
            (cd "$version_dir" && _espvm_run_quiet ./install.sh) || return 1
            echo -n "Retrying activation... "
            if _espvm_source_quiet "$version_dir/export.sh"; then
                _espvm_green "done"
            else
                _espvm_red "failed"
                return 1
            fi
        else
            return 1
        fi
    else
        # Verify activation - different checks for IDF vs Matter
        local activation_ok=0
        if [[ "$sdk" == "idf" ]]; then
            [[ "$IDF_PATH" == "$version_dir" ]] && command -v idf.py &>/dev/null && activation_ok=1
        else
            [[ "$ESP_MATTER_PATH" == "$version_dir" ]] && activation_ok=1
        fi
        if [[ $activation_ok -eq 0 ]]; then
            _espvm_red "failed"
            if [[ $just_installed -eq 1 ]]; then
                return 1
            fi
            read -p "Run install.sh to fix? [y/N]: " answer
            if [[ "$answer" =~ ^[Yy]$ ]]; then
                (cd "$version_dir" && _espvm_run_quiet ./install.sh) || return 1
                echo -n "Retrying activation... "
                _espvm_source_quiet "$version_dir/export.sh"
                _espvm_green "done"
            else
                return 1
            fi
        else
            _espvm_green "done"
        fi
    fi

    # Save current version (encoded for consistency)
    mkdir -p "$(dirname "$current_file")"
    echo "$encoded_version" > "$current_file"

    _espvm_green "Now using $sdk_name $version"
    return 0
}

# List installed versions
_espvm_list() {
    local sdk="$1"
    local sdk_name="${_ESPVM_SDKS[$sdk]}"
    local sdk_dir="$(_espvm_get_sdk_dir "$sdk")"

    if [[ ! -d "$sdk_dir" ]]; then
        echo "No $sdk_name versions installed"
        return 0
    fi

    echo "Installed $sdk_name versions:"
    local found=0
    for dir in "$sdk_dir"/*/; do
        if [[ -d "$dir" ]]; then
            local encoded_ver=$(basename "$dir")
            # Skip hidden directories
            [[ "$encoded_ver" == .* ]] && continue
            local ver=$(_espvm_decode_version "$encoded_ver")
            local ver_dir="${dir%/}"
            found=1
            # Check if actually active
            local is_active=0
            if [[ "$sdk" == "idf" && "$IDF_PATH" == "$ver_dir" ]]; then
                is_active=1
            elif [[ "$sdk" == "matter" && "$ESP_MATTER_PATH" == "$ver_dir" ]]; then
                is_active=1
            fi
            if [[ $is_active -eq 1 ]]; then
                _espvm_green "* $ver (active)"
            else
                echo "  $ver"
            fi
        fi
    done

    if [[ $found -eq 0 ]]; then
        echo "  (none)"
    fi
    return 0
}

# List available remote versions
_espvm_list_remote() {
    local sdk="$1"
    local sdk_name="${_ESPVM_SDKS[$sdk]}"
    local repo_url="$(_espvm_get_repo_url "$sdk")"

    echo "Fetching available $sdk_name versions..."
    echo ""

    # Get tags (releases)
    _espvm_blue "Tags (releases):"
    local tags=$(git ls-remote --tags "$repo_url" 2>/dev/null | \
        sed 's/.*refs\/tags\///' | \
        grep -v '\^{}' | \
        grep '^v[0-9]' | \
        sort -V -r | \
        head -20)

    if [[ -n "$tags" ]]; then
        echo "$tags" | sed 's/^/  /'
    else
        echo "  (none found)"
    fi

    echo ""

    # Get branches
    _espvm_blue "Branches:"
    local branches=$(git ls-remote --heads "$repo_url" 2>/dev/null | \
        sed 's/.*refs\/heads\///' | \
        head -20)

    if [[ -n "$branches" ]]; then
        echo "$branches" | sed 's/^/  /'
    else
        echo "  (none found)"
    fi

    echo ""
    echo "Use 'espvm $sdk install <version>' to install a specific version"
    return 0
}

# Remove an installed version
_espvm_remove() {
    local sdk="$1"
    local version="$2"

    if [[ -z "$version" ]]; then
        _espvm_red "Usage: espvm $sdk remove <version>"
        return 1
    fi

    local sdk_name="${_ESPVM_SDKS[$sdk]}"
    version=$(_espvm_normalize_version "$version")
    local encoded_version=$(_espvm_encode_version "$version")
    local sdk_dir="$(_espvm_get_sdk_dir "$sdk")"
    local version_dir="$sdk_dir/$encoded_version"
    local bare_dir="$(_espvm_get_bare_dir "$sdk")"
    local current_file="$(_espvm_get_current_file "$sdk")"

    if [[ ! -d "$version_dir" ]]; then
        _espvm_red "Error: $sdk_name $version is not installed"
        return 1
    fi

    # Check if it's the current version
    local current=""
    if [[ -f "$current_file" ]]; then
        current=$(cat "$current_file")
    fi

    if [[ "$encoded_version" == "$current" ]]; then
        _espvm_yellow "Warning: $version is currently active"
    fi

    echo "Removing $sdk_name $version..."

    # Ensure bare repo exists for worktree operations
    _espvm_ensure_bare "$sdk"

    # Remove worktree
    git -C "$bare_dir" worktree remove "$version_dir" --force 2>/dev/null
    if [[ $? -ne 0 ]]; then
        # Fallback to manual removal
        rm -rf "$version_dir"
    fi

    # Prune worktrees
    git -C "$bare_dir" worktree prune 2>/dev/null

    # Clear current if removed
    if [[ "$encoded_version" == "$current" ]]; then
        rm -f "$current_file"
    fi

    _espvm_green "$sdk_name $version removed successfully"
    return 0
}

# Update an installed version
_espvm_update() {
    local sdk="$1"
    local version="$2"

    if [[ -z "$version" ]]; then
        _espvm_red "Usage: espvm $sdk update <version>"
        return 1
    fi

    local sdk_name="${_ESPVM_SDKS[$sdk]}"
    version=$(_espvm_normalize_version "$version")
    local encoded_version=$(_espvm_encode_version "$version")
    local sdk_dir="$(_espvm_get_sdk_dir "$sdk")"
    local version_dir="$sdk_dir/$encoded_version"
    local bare_dir="$(_espvm_get_bare_dir "$sdk")"

    if [[ ! -d "$version_dir" ]]; then
        _espvm_red "Error: $sdk_name $version is not installed"
        return 1
    fi

    echo "Updating $sdk_name $version..."

    # Ensure bare repo exists
    _espvm_ensure_bare "$sdk" || return 1

    # Fetch latest
    git -C "$bare_dir" fetch origin tag "$version" --force 2>/dev/null || \
        git -C "$bare_dir" fetch origin "$version" --force
    if [[ $? -ne 0 ]]; then
        _espvm_red "Error: Failed to fetch updates"
        return 1
    fi

    # Reset worktree to the tag
    git -C "$version_dir" checkout "$version"
    git -C "$version_dir" reset --hard "$version"

    # Update submodules
    echo "Updating submodules..."
    git -C "$version_dir" submodule update --init --recursive
    if [[ $? -ne 0 ]]; then
        _espvm_red "Error: Failed to update submodules"
        return 1
    fi

    # Check and install tools if needed
    _espvm_maybe_install "$version_dir" "$version" "$sdk" || return 1

    _espvm_green "$sdk_name $version updated successfully"
    return 0
}

# Show current version
_espvm_current() {
    local sdk="$1"
    local sdk_name="${_ESPVM_SDKS[$sdk]}"
    local current_file="$(_espvm_get_current_file "$sdk")"

    if [[ -f "$current_file" ]]; then
        local encoded_current=$(cat "$current_file")
        local current=$(_espvm_decode_version "$encoded_current")
        echo "Current $sdk_name version: $current"
        if [[ "$sdk" == "idf" && -n "$IDF_PATH" ]]; then
            echo "IDF_PATH: $IDF_PATH"
        elif [[ "$sdk" == "matter" && -n "$ESP_MATTER_PATH" ]]; then
            echo "ESP_MATTER_PATH: $ESP_MATTER_PATH"
        fi
    else
        echo "No $sdk_name version currently active"
        echo "Run 'espvm $sdk use <version>' to activate a version"
    fi
    return 0
}

# Show status of all SDKs
_espvm_status() {
    echo "ESP-IDF:"
    if [[ -n "$IDF_PATH" ]]; then
        _espvm_green "  $(basename "$IDF_PATH") (active)"
    else
        echo "  (not active)"
    fi

    echo "ESP-Matter:"
    if [[ -n "$ESP_MATTER_PATH" ]]; then
        _espvm_green "  $(basename "$ESP_MATTER_PATH") (active)"
    else
        echo "  (not active)"
    fi
}

# Show/set configuration
espvm_config() {
    local action="$1"
    local key="$2"
    local value="$3"

    _espvm_load_config

    if [[ -z "$action" ]] || [[ "$action" == "show" ]]; then
        echo "espvm configuration:"
        echo ""
        echo "Config file: $ESPVM_CONFIG_FILE"
        echo ""
        echo "Settings:"
        echo "  ESPVM_WORKTREE_DIR: ${ESPVM_WORKTREE_DIR:-<not set>}"
        echo "  ESPVM_USE_SSH: ${ESPVM_USE_SSH:-auto}"
        echo ""
        echo "Bare repositories:"
        for sdk in "${!_ESPVM_SDKS[@]}"; do
            local bare_dir="$(_espvm_get_bare_dir "$sdk")"
            if [[ -d "$bare_dir" ]]; then
                echo "  ${_ESPVM_SDKS[$sdk]}: $bare_dir"
            fi
        done
        return 0
    fi

    if [[ "$action" == "set" ]]; then
        case "$key" in
            worktree-dir|worktree_dir|ESPVM_WORKTREE_DIR)
                if [[ -z "$value" ]]; then
                    _espvm_red "Usage: espvm config set worktree-dir <path>"
                    return 1
                fi
                # Expand ~ and convert to absolute path
                value="${value/#\~/$HOME}"
                if [[ "$value" != /* ]]; then
                    value="$(cd "$value" 2>/dev/null && pwd)" || value="$(pwd)/$value"
                fi
                ESPVM_WORKTREE_DIR="$value"
                _espvm_save_config
                _espvm_green "worktree-dir set to: $ESPVM_WORKTREE_DIR"
                ;;
            use-ssh|use_ssh|ESPVM_USE_SSH)
                if [[ ! "$value" =~ ^(auto|yes|no)$ ]]; then
                    _espvm_red "Usage: espvm config set use-ssh <auto|yes|no>"
                    return 1
                fi
                ESPVM_USE_SSH="$value"
                _espvm_save_config
                _espvm_green "use-ssh set to: $ESPVM_USE_SSH"
                ;;
            *)
                _espvm_red "Unknown config key: $key"
                echo "Available keys: worktree-dir, use-ssh"
                return 1
                ;;
        esac
        return 0
    fi

    if [[ "$action" == "reset" ]]; then
        rm -f "$ESPVM_CONFIG_FILE"
        _espvm_green "Configuration reset"
        return 0
    fi

    _espvm_red "Unknown config action: $action"
    echo "Usage: espvm config [show|set <key> <value>|reset]"
    return 1
}

# Show help for SDK commands
_espvm_sdk_help() {
    local sdk="$1"
    local sdk_name="${_ESPVM_SDKS[$sdk]}"

    cat << EOF
Usage: espvm $sdk <command> [args]

Commands:
  install <ver> [-v] [--force]   Install version (tag or branch)
  use <ver> [-v]                 Activate version in current shell
  list                           List installed versions
  list-remote                    List available tags and branches
  remove <ver>                   Remove installed version
  update <ver>                   Update version to latest
  current                        Show active version
  repair                         Fix broken worktree links

Flags:
  -v, --verbose                  Show full output from install/export

Examples:
  espvm $sdk install 5.4.1
  espvm $sdk use 5.4.1
  espvm $sdk list-remote
EOF
}

# Handle SDK subcommands
_espvm_sdk_command() {
    local sdk="$1"
    local cmd="$2"
    shift 2

    case "$cmd" in
        install)
            _espvm_install "$sdk" "$@"
            ;;
        use)
            _espvm_use "$sdk" "$@"
            ;;
        list)
            _espvm_list "$sdk"
            ;;
        list-remote)
            _espvm_list_remote "$sdk"
            ;;
        remove)
            _espvm_remove "$sdk" "$@"
            ;;
        update)
            _espvm_update "$sdk" "$@"
            ;;
        current)
            _espvm_current "$sdk"
            ;;
        repair)
            _espvm_ensure_bare "$sdk" || return 1
            _espvm_repair_worktrees "$sdk"
            _espvm_green "Worktree links repaired"
            ;;
        help|--help|-h|"")
            _espvm_sdk_help "$sdk"
            ;;
        *)
            _espvm_red "Unknown command: $cmd"
            _espvm_sdk_help "$sdk"
            return 1
            ;;
    esac
}

# Show main help
espvm_help() {
    cat << 'EOF'
espvm - ESP SDK Version Manager

Usage:
  espvm [-i|-m] <version>     Activate version (install if needed)
  espvm [-i|-m] <command>     Run command

SDK Flags:
  -i    ESP-IDF (default)
  -m    ESP-Matter

Commands:
  i <ver>         Install version
  use <ver>       Activate version
  ls              List installed
  remote          List available
  rm <ver>        Remove version
  status          Show active versions
  config          Configuration

Legacy:
  espvm idf <cmd>     Full SDK name still works
  espvm matter <cmd>

Examples:
  espvm 5.4.1         Activate IDF 5.4.1
  espvm i 5.5         Install IDF 5.5
  espvm -m i 1.0      Install Matter 1.0
  espvm -m use 1.0    Activate Matter 1.0
  espvm ls            List IDF versions
  espvm -m ls         List Matter versions
  espvm status        Show what's active

EOF
}

# Main entry point
espvm() {
    local sdk="idf"  # Default SDK

    # Parse SDK flag first
    case "$1" in
        -i) sdk="idf"; shift ;;
        -m) sdk="matter"; shift ;;
    esac

    local cmd="$1"
    shift 2>/dev/null || true

    # Smart version detection: v5.4.1, 5.4.1, release/v5.0
    if [[ "$cmd" =~ ^v?[0-9] ]] || [[ "$cmd" =~ ^release[/-] ]]; then
        _espvm_use "$sdk" "$cmd" "$@"
        return
    fi

    case "$cmd" in
        # Legacy full names still work
        idf|matter)
            _espvm_sdk_command "$cmd" "$@"
            ;;
        # Commands use selected SDK
        i|install)
            _espvm_sdk_command "$sdk" "install" "$@"
            ;;
        use)
            _espvm_sdk_command "$sdk" "use" "$@"
            ;;
        ls|list)
            _espvm_list "$sdk"
            ;;
        remote|list-remote)
            _espvm_list_remote "$sdk"
            ;;
        rm|remove)
            _espvm_remove "$sdk" "$@"
            ;;
        update)
            _espvm_update "$sdk" "$@"
            ;;
        current)
            _espvm_current "$sdk"
            ;;
        repair)
            _espvm_ensure_bare "$sdk" || return 1
            _espvm_repair_worktrees "$sdk"
            _espvm_green "Worktree links repaired"
            ;;
        status)
            _espvm_status
            ;;
        config)
            espvm_config "$@"
            ;;
        help|--help|-h|"")
            espvm_help
            ;;
        *)
            _espvm_red "Unknown: $cmd"
            espvm_help
            return 1
            ;;
    esac
}

# If script is executed (not sourced), run main function
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    espvm "$@"
fi
